    //Boolean result = false;
    //int i = 0;
    //int idx1, idx0;
    
    //while (!result && i < 4) {

    //  if (i < 3) {
    //    idx0 = i;
    //    idx1 = i + 1;
    //  } else {
    //    idx0 = i;
    //    idx1 = 0;
    //  }
      
    
    //  PVector p0 = corners[idx0];
      
    //  PVector p1 = corners[idx1];
      
    //  tempVec = closestPointOnLine(p1.x, p1.y, p0.x, p0.y,
    //                                 centre.x, centre.y);
                                     
    //  float dist = PVector.dist(tempVec, centre);                         
    //  result = dist < radius;
      
    //  i++;
      
    //}
    
    //return result;
    
    //float tempX;
    //float tempY;
    
    //this.centre = getCentre();
    
    //if (angle == 0) {
    //  tempX = centre.x;
    //  tempY = centre.y;
      
    //} else {
      
    //  float s = sin (angle);
    //  float c = cos (angle);
      
    //  float cx = centre.x - (this.centre.x - this.pivot.x);
    //  float cy = centre.y - (this.centre.y - this.pivot.y);
    //  //float cx = radius * c;
    //  //float cy = radius * s;
      
    //  ellipse (cx, cy, 5, 5);

    //  tempX = c * cx - s * cy + (this.centre.x + pivot.x);
    //  tempY = s * cx + c * cy + (this.centre.y + pivot.y);
      
    //  ellipse (tempX, tempY, 5, 5);
    //}
    
    //testX = tempX;
    //testY = tempY;
    
    //println ("tempX : " + tempX + "\ttempY : " + tempY);
   
    
    //float dX = abs (tempX - (this.centre.x - this.pivot.x));
    //float dY = abs (tempY - (this.centre.y - this.pivot.y));
    
    //if (dX > (this.w / 2.0 + radius)) return false;
    //if (dY > (this.h / 2.0 + radius)) return false;
    
    //if (dX < (this.w / 2.0 + radius)) return true;
    //if (dY < (this.h / 2.0 + radius)) return true;
    
    //float cornerDist_sqr = (dX - w / 2.0) * (dX - w / 2.0) + (dY - h / 2.0) * (dY - h / 2.0);
    
    //return cornerDist_sqr <= radius * radius;
    
    